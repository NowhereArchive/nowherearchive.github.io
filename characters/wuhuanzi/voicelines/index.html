<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google Tag Manager -->
  <script>(function (w, d, s, l, i) {
      w[l] = w[l] || []; w[l].push({
        'gtm.start':
          new Date().getTime(), event: 'gtm.js'
      }); var f = d.getElementsByTagName(s)[0],
        j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
          'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-WCKMLLZJ');</script>
  <!-- End Google Tag Manager -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3M02N0366N"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-702GZFHJQE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-3M02N0366N");
  </script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-702GZFHJQE');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description"
    content="Listen to all Wuhuanzi voice lines from Path To Nowhere. Complete collection of character quotes and audio in multiple languages including English, Japanese, Chinese, and Korean." />
  <title>Wuhuanzi Voicelines - Path To Nowhere Archive</title>
  <link href="../../Styles.css" rel="stylesheet" />
  <link href="../../NavBar.css" rel="stylesheet" />
  <link href="../../css/utilities.css" rel="stylesheet" />
  <style>
    .hero-controls {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
    }

    .search-container {
      position: relative;
      max-width: 600px;
      margin: 2rem auto;
      width: 100%;
    }

    .search-input {
      width: 100%;
      padding: 1rem 1.5rem;
      padding-right: 8rem;
      font-size: 1.1rem;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 50px;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      color: white;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    .search-shortcut {
      position: absolute;
      right: 3.5rem;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.75rem;
      font-family: monospace;
      pointer-events: none;
      opacity: 0.6;
      transition: all 0.3s ease;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      background: transparent;
      border: none;
      padding: 0;
    }

    .search-container:focus-within .search-shortcut {
      opacity: 0;
      transform: translateY(-50%) scale(0.9);
    }

    .search-input:focus {
      outline: none;
      border-color: #9c1111;
      box-shadow: 0 0 0 3px rgba(156, 17, 17, 0.3);
    }

    .search-button {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .search-button:hover {
      color: white;
      background: rgba(255, 255, 255, 0.1);
    }

    .button-groups {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .language-buttons,
    .attire-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
    }

    .language-buttons button,
    .attire-buttons button {
      padding: 0.5rem 1.25rem;
      border: none;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
      font-family: 'Lato', sans-serif;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .language-buttons button:hover,
    .attire-buttons button:hover {
      background: rgba(156, 17, 17, 0.3);
      color: white;
    }

    .language-buttons button.active,
    .attire-buttons button.active {
      background: #9c1111;
      color: white;
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .button-groups {
        flex-direction: column;
        align-items: center;
      }

      .language-buttons,
      .attire-buttons {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WCKMLLZJ" height="0" width="0"
      style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header">
        <button title="logo" class="navbar-toggler" data-toggle="open-navbar1">
          <span></span>
          <span></span>
          <span></span>
        </button>
        <a href="/">
          <h4>Path To Nowhere Archive</h4>
        </a>
      </div>

      <div class="navbar-menu" id="open-navbar1">
        <ul class="navbar-nav">
          <!-- <li><a href="/Game">Game</a></li> -->
          <li><a href="/CGs">CGs</a></li>
          <li><a href="/characters">Characters</a></li>

        </ul>
      </div>
    </div>
  </nav>
  
  <!-- Breadcrumbs -->
  <div data-breadcrumbs="characters/wuhuanzi"></div>
  
  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-content">
      <h1 id="characterName">Wuhuanzi</h1>
      <div class="hero-controls">
        <div class="search-container">
          <input type="text" id="searchInput" class="search-input" placeholder="Search voicelines..."
            autocomplete="off" aria-label="Search voicelines" />
          <span class="search-shortcut" title="Press / to search">/</span>
          <button class="search-button" id="searchButton">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
          </button>
        </div>
        <div class="button-groups">
          <div class="language-buttons" id="languageButtonsContainer"></div>
          <div class="attire-buttons" id="attireButtonsContainer"></div>
        </div>
      </div>
    </div>
    <div class="hero-overlay"></div>
  </section>

  <div id="voicelinesContainer"></div>

  <script src="../../js/utilities.js"></script>
  <script>
    const characterName = "wuhuanzi";
    let language = "english";

    let attireDisplayNames = {};

    async function loadCharacterData() {
      try {
        const response = await fetch('../../characters.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        const character = data.characters.find(c => c.name === characterName);

        if (character && character.attires) {
          character.attires.forEach(attire => {
            attireDisplayNames[attire.name] = attire.displayName;
          });
        }
        return true;
      } catch (error) {
        console.error('Error loading character data:', error);
        if (typeof showError === 'function') {
          showError('Failed to load character data. Some features may be unavailable.');
        }
        return false;
      }
    }

    async function init() {
      await loadCharacterData();
      createLanguageButtons();
      loadVoicelines();
    }

    init();

    function sanitizeName(name) {
      return name.toLowerCase().replace(/\s+/g, "_");
    }

    function trimFilePrefix(filename) {
      return filename.startsWith("File:") ? filename.slice(5) : filename;
    }

    function renderVoicelines(data, sanitizedAttire, sanitizedLanguage) {
      const voicelinesContainer = document.getElementById(
        "voicelinesContainer"
      );
      const voicelines = data[sanitizedAttire];

      if (!voicelines) {
        voicelinesContainer.innerHTML = `
          <div class="error-container">
            <h3>No Voicelines Found</h3>
            <p>No voice lines found for ${sanitizedAttire} in ${sanitizedLanguage}.</p>
          </div>
        `;
        return;
      }
      
      // Show loading state
      let loadingDiv = null;
      if (typeof showLoading === 'function') {
        loadingDiv = showLoading(voicelinesContainer, 'Loading voicelines...');
      }

      const englishVoicelinesFile = `../../CharactersJson/${characterName}_english.json`;
      const englishVoicelineMap = {};

      if (sanitizedLanguage !== "english") {
        fetch(englishVoicelinesFile)
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((englishData) => {
            const englishVoicelines = englishData[sanitizedAttire];

            if (englishVoicelines) {
              englishVoicelines.forEach((voiceline) => {
                englishVoicelineMap[voiceline.title] = voiceline.text;
              });
            }
            displayVoicelines(
              voicelinesContainer,
              voicelines,
              sanitizedAttire,
              englishVoicelineMap,
              loadingDiv
            );
            filterVoicelines();
          })
          .catch((error) => {
            console.error("Error loading English voicelines:", error);
            if (loadingDiv && typeof hideLoading === 'function') {
              hideLoading(loadingDiv);
            }
            voicelinesContainer.innerHTML = `
              <div class="error-container">
                <h3>Error Loading Translations</h3>
                <p>Failed to load English translations. Showing original language only.</p>
                <button onclick="location.reload()">Reload Page</button>
              </div>
            `;
          });
      } else {
        displayVoicelines(voicelinesContainer, voicelines, sanitizedAttire, null, loadingDiv);
        filterVoicelines();
      }
    }

    function displayVoicelines(
      container,
      voicelines,
      sanitizedAttire,
      englishVoicelineMap = {},
      loadingDiv = null
    ) {
      // Hide loading state if provided
      if (loadingDiv && typeof hideLoading === 'function') {
        hideLoading(loadingDiv);
      }
      
      container.innerHTML = "";

      voicelines.forEach((voiceline) => {
        const trimmedFilename = trimFilePrefix(voiceline.filename);
        console.log(sanitizedAttire);
        const sanitizedAudioFile = `https://raw.githubusercontent.com/NowhereArchive/NowhereAudios/main/audio/${characterName}/${language}/${sanitizedAttire}/${sanitizeName(
          trimmedFilename
        )}`;

        const lineDiv = document.createElement("div");
        lineDiv.className = 'voiceline-card';
        const hasTranslation = language !== "english" && englishVoicelineMap[voiceline.title];

        lineDiv.innerHTML = `
          <div class="voiceline-header">
            <div class="voiceline-title">${voiceline.title}</div>
            <div class="voiceline-actions">
              <button class="action-btn copy-btn" title="Copy text">
                <svg viewBox="0 0 24 24" width="16" height="16">
                  <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                </svg>
              </button>
              <button class="action-btn download-btn" title="Download" data-audio="${sanitizedAudioFile}">
                <svg viewBox="0 0 24 24" width="16" height="16">
                  <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
              </button>
              ${navigator.share ? `
              <button class="action-btn share-btn" title="Share">
                <svg viewBox="0 0 24 24" width="16" height="16">
                  <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92c0-1.61-1.31-2.92-2.92-2.92zM18 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM6 13c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm12 7.02c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/>
                </svg>
              </button>` : ''}
            </div>
          </div>
          <div class="voiceline-content">
            <div class="voiceline-text">${voiceline.text}</div>
            ${hasTranslation ? `
              <div class="translation-toggle">
                <button class="translation-btn">Show Translation</button>
              </div>
              <div class="voiceline-translation" style="display: none;">
                <div class="translation-label">English:</div>
                <div class="translation-text">${englishVoicelineMap[voiceline.title]}</div>
              </div>` : ''}
          </div>
          <div class="voiceline-controls">
            <button class="play-btn" data-audio="${sanitizedAudioFile}">
              <svg class="play-icon" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
              <svg class="pause-icon" viewBox="0 0 24 24" style="display: none;">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
              </svg>
            </button>
            <div class="progress-container">
              <div class="progress-bar"></div>
            </div>
            <div class="voiceline-duration">0:00</div>
          </div>
        `;

        const playBtn = lineDiv.querySelector('.play-btn');
        if (playBtn) {
          playBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const audioFile = playBtn.getAttribute('data-audio');
            playVoice(audioFile, lineDiv);
          });
        }

        const copyBtn = lineDiv.querySelector('.copy-btn');
        if (copyBtn) {
          copyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const textToCopy = lineDiv.querySelector('.voiceline-text').textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
              const originalHTML = copyBtn.innerHTML;
              copyBtn.innerHTML = `<svg viewBox="0 0 24 24" width="16" height="16"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`;
              copyBtn.setAttribute('aria-label', 'Copied!');
              setTimeout(() => {
                copyBtn.innerHTML = originalHTML;
                copyBtn.setAttribute('aria-label', 'Copy text');
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy text:', err);
              if (typeof showError === 'function') {
                showError('Failed to copy text to clipboard.');
              }
            });
          });
        }

        const downloadBtn = lineDiv.querySelector('.download-btn');
        if (downloadBtn) {
          downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const audioUrl = downloadBtn.getAttribute('data-audio');
            const fileName = audioUrl.split('/').pop();
            const a = document.createElement('a');
            a.href = audioUrl;
            a.download = fileName || 'voiceline.mp3';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
          });
        }

        const shareBtn = lineDiv.querySelector('.share-btn');
        if (shareBtn && navigator.share) {
          shareBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const title = lineDiv.querySelector('.voiceline-title').textContent;
            const text = lineDiv.querySelector('.voiceline-text').textContent;
            const url = window.location.href;

            navigator.share({
              title: `${characterName} - ${title}`,
              text: text,
              url: url
            }).catch(console.error);
          });
        }

        const translationBtn = lineDiv.querySelector('.translation-btn');
        const translationDiv = lineDiv.querySelector('.voiceline-translation');
        if (translationBtn && translationDiv) {
          translationBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isHidden = translationDiv.style.display === 'none';
            translationDiv.style.display = isHidden ? 'block' : 'none';
            translationBtn.textContent = isHidden ? 'Hide Translation' : 'Show Translation';
          });
        }

        const progressContainer = lineDiv.querySelector('.progress-container');
        if (progressContainer) {
          progressContainer.addEventListener('click', (e) => {
            if (!currentAudio || !isFinite(currentAudio.duration) || currentAudio.duration <= 0) return;

            const rect = progressContainer.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            currentAudio.currentTime = pos * currentAudio.duration;

            const progressBar = progressContainer.querySelector('.progress-bar');
            const durationDisplay = lineDiv.querySelector('.voiceline-duration');
            
            if (progressBar) {
              progressBar.style.width = `${pos * 100}%`;
            }
            
            if (durationDisplay) {
              durationDisplay.textContent = formatTime(currentAudio.currentTime);
            }
          });
        }

        container.appendChild(lineDiv);
      });
    }

    function createAttireButtons(data) {
      const attireButtonsContainer = document.getElementById("attireButtonsContainer");
      attireButtonsContainer.innerHTML = "";

      Object.keys(data).forEach((attire) => {
        const button = document.createElement("button");
        button.classList.add("attire-button");
        button.innerText = attireDisplayNames[attire] ||
          attire.replace(/_/g, " ").replace(/\b\w/g, (char) => char.toUpperCase());


        button.setAttribute('aria-label', `Switch to ${button.innerText} attire`);
        button.onclick = () => {
          const buttons = attireButtonsContainer.getElementsByClassName("attire-button");
          Array.from(buttons).forEach((btn) => btn.classList.remove("active-button"));

          button.classList.add("active-button");

          const searchValue = document.getElementById("searchInput").value;

          renderVoicelines(data, attire, language);

          document.getElementById("searchInput").value = searchValue;
          filterVoicelines();
        };
        attireButtonsContainer.appendChild(button);
      });
    }

    function createLanguageButtons() {
      const languageButtonsContainer = document.getElementById(
        "languageButtonsContainer"
      );
      const languages = ["English", "Japanese", "Chinese", "Korean"];
      const availableLanguages = [];

      const languagePromises = languages.map((lang) => {
        const languageFile = `../../CharactersJson/${characterName}_${sanitizeName(
          lang
        )}.json`;
        return fetch(languageFile)
          .then((response) => {
            if (response.ok) {
              availableLanguages.push(lang);
              const button = document.createElement("button");
              button.classList.add("language-button");
              button.innerText = lang;
              button.setAttribute('aria-label', `Switch to ${lang} language`);
              button.onclick = () => {
                const buttons =
                  languageButtonsContainer.getElementsByClassName(
                    "language-button"
                  );
                Array.from(buttons).forEach((btn) =>
                  btn.classList.remove("active-button")
                );

                button.classList.add("active-button");
                language = sanitizeName(lang);
                loadVoicelines();
              };
              languageButtonsContainer.appendChild(button);
            }
          })
          .catch((error) => {
            console.error(`Error loading ${lang} file:`, error);
            // Silently fail for unavailable languages
          });
      });
      
      // Set first available language as active
      Promise.all(languagePromises).then(() => {
        const firstButton = languageButtonsContainer.querySelector('.language-button');
        if (firstButton) {
          firstButton.classList.add('active-button');
        }
      });
    }

    function capitalizeWords(name) {
      return name
        .split(" ")
        .map(
          (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        )
        .join(" ");
    }

    async function loadVoicelines() {
      const voicelinesFile = `../../CharactersJson/${characterName}_${language}.json`;
      const voicelinesContainer = document.getElementById("voicelinesContainer");
      
      // Show loading state
      let loadingDiv = null;
      if (typeof showLoading === 'function') {
        loadingDiv = showLoading(voicelinesContainer, 'Loading voicelines...');
      }

      try {
        const response = await fetch(voicelinesFile);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        if (loadingDiv && typeof hideLoading === 'function') {
          hideLoading(loadingDiv);
        }

        createAttireButtons(data);
        renderVoicelines(data, Object.keys(data)[0], language);
      } catch (error) {
        console.error("Error loading voice lines:", error);
        if (loadingDiv && typeof hideLoading === 'function') {
          hideLoading(loadingDiv);
        }
        voicelinesContainer.innerHTML = `
          <div class="error-container">
            <h3>Error Loading Voicelines</h3>
            <p>Failed to load voice lines. Please check your connection and try again.</p>
            <button onclick="location.reload()">Reload Page</button>
          </div>
        `;
      }
    }

    let currentAudio = null;
    let currentPlayingCard = null;
    let currentProgressInterval = null;

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function updateProgress(card) {
      // Clear any existing interval
      if (currentProgressInterval) clearInterval(currentProgressInterval);

      // Function to update progress bar
      const updateProgressBar = () => {
        if (!currentAudio || !card) return;
        
        const duration = currentAudio.duration;
        const currentTime = currentAudio.currentTime;
        
        // Validate duration (check for NaN, Infinity, or 0)
        if (!isFinite(duration) || duration <= 0) {
          return; // Duration not loaded yet or invalid
        }
        
        const progress = Math.min(100, Math.max(0, (currentTime / duration) * 100));
        const progressBar = card.querySelector('.progress-bar');
        const durationDisplay = card.querySelector('.voiceline-duration');

        if (progressBar) {
          progressBar.style.width = `${progress}%`;
        }

        if (durationDisplay) {
          durationDisplay.textContent = formatTime(currentTime);
        }
      };

      // Use timeupdate event for more accurate updates (fires ~4 times per second)
      const timeUpdateHandler = () => {
        updateProgressBar();
      };
      
      currentAudio.addEventListener('timeupdate', timeUpdateHandler);
      
      // Also use interval as backup (every 100ms for smoother updates)
      currentProgressInterval = setInterval(() => {
        updateProgressBar();
      }, 100);

      // Handle audio end - ensure progress reaches 100%
      currentAudio.addEventListener('ended', function onEnd() {
        // Clear interval
        if (currentProgressInterval) {
          clearInterval(currentProgressInterval);
          currentProgressInterval = null;
        }
        
        // Remove timeupdate listener
        currentAudio.removeEventListener('timeupdate', timeUpdateHandler);
        
        // Ensure progress bar reaches 100%
        const progressBar = card.querySelector('.progress-bar');
        if (progressBar) {
          progressBar.style.width = '100%';
        }
        
        // Update duration display to show final time
        const durationDisplay = card.querySelector('.voiceline-duration');
        if (durationDisplay && currentAudio.duration) {
          durationDisplay.textContent = formatTime(currentAudio.duration);
        }
        
        // Reset play button
        const playBtn = card.querySelector('.play-btn');
        if (playBtn) {
          playBtn.querySelector('.play-icon').style.display = 'block';
          playBtn.querySelector('.pause-icon').style.display = 'none';
        }
        
        // Reset after a brief moment
        setTimeout(() => {
          if (progressBar) {
            progressBar.style.width = '0%';
          }
          if (durationDisplay) {
            durationDisplay.textContent = '0:00';
          }
        }, 500);
      }, { once: true });
      
      // Store handler for cleanup
      currentAudio._timeUpdateHandler = timeUpdateHandler;
    }

    function playVoice(file, card) {
      if (currentPlayingCard === card) {
        if (currentAudio && !currentAudio.paused) {
          currentAudio.pause();
          const playBtn = card.querySelector('.play-btn');
          if (playBtn) {
            playBtn.querySelector('.play-icon').style.display = 'block';
            playBtn.querySelector('.pause-icon').style.display = 'none';
          }
          // Clear interval but keep timeupdate listener for when we resume
          if (currentProgressInterval) {
            clearInterval(currentProgressInterval);
            currentProgressInterval = null;
          }
          return;
        } else if (currentAudio) {
          currentAudio.play();
          const playBtn = card.querySelector('.play-btn');
          if (playBtn) {
            playBtn.querySelector('.play-icon').style.display = 'none';
            playBtn.querySelector('.pause-icon').style.display = 'block';
          }
          updateProgress(card);
          return;
        }
      }

      stopVoice();

      currentAudio = new Audio(file);
      currentPlayingCard = card;

      const playBtn = card.querySelector('.play-btn');
      if (playBtn) {
        playBtn.querySelector('.play-icon').style.display = 'none';
        playBtn.querySelector('.pause-icon').style.display = 'block';
      }

      currentAudio.addEventListener('loadedmetadata', function () {
        const durationDisplay = card.querySelector('.voiceline-duration');
        if (durationDisplay) {
          durationDisplay.textContent = formatTime(currentAudio.duration);
        }
      });

      currentAudio.play().then(() => {
        updateProgress(card);
      }).catch(error => {
        console.error('Error playing audio:', error);
        if (typeof showError === 'function') {
          showError('Failed to play audio. The file may be unavailable or corrupted.');
        }
        // Reset UI on error
        const playBtn = card.querySelector('.play-btn');
        if (playBtn) {
          playBtn.querySelector('.play-icon').style.display = 'block';
          playBtn.querySelector('.pause-icon').style.display = 'none';
        }
        currentAudio = null;
        currentPlayingCard = null;
      });
    }

    function stopVoice() {
      if (currentAudio) {
        // Remove timeupdate listener if it exists
        if (currentAudio._timeUpdateHandler) {
          currentAudio.removeEventListener('timeupdate', currentAudio._timeUpdateHandler);
          delete currentAudio._timeUpdateHandler;
        }
        
        if (currentPlayingCard) {
          const playBtn = currentPlayingCard.querySelector('.play-btn');
          if (playBtn) {
            playBtn.querySelector('.play-icon').style.display = 'block';
            playBtn.querySelector('.pause-icon').style.display = 'none';
          }
          const progressBar = currentPlayingCard.querySelector('.progress-bar');
          if (progressBar) progressBar.style.width = '0%';
          
          const durationDisplay = currentPlayingCard.querySelector('.voiceline-duration');
          if (durationDisplay) durationDisplay.textContent = '0:00';
        }

        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
        currentPlayingCard = null;
        
        if (currentProgressInterval) {
          clearInterval(currentProgressInterval);
          currentProgressInterval = null;
        }
      }
    }

    // Keyboard shortcuts
    document.addEventListener("keydown", function (event) {
      const searchInput = document.getElementById("searchInput");
      
      // Focus search with / or L
      if (
        (event.key === "/" || event.key === "l" || event.key === "L") &&
        document.activeElement !== searchInput &&
        !event.target.matches('input, textarea, [contenteditable]')
      ) {
        event.preventDefault();
        if (searchInput) {
          searchInput.focus();
        }
      }
      
      // Escape to clear search
      if (event.key === "Escape" && document.activeElement === searchInput) {
        searchInput.value = '';
        filterVoicelines();
        searchInput.blur();
      }
    });

    document
      .getElementById("searchInput")
      .addEventListener("input", filterVoicelines);

    function filterVoicelines() {
      const searchValue = document.getElementById("searchInput").value.toLowerCase().trim();
      const voicelines = document.querySelectorAll(".voiceline-card");
      let visibleCount = 0;

      voicelines.forEach((line) => {
        const lineTitle = line.querySelector(".voiceline-title")?.innerText.toLowerCase() || '';
        const lineText = line.querySelector(".voiceline-text")?.innerText.toLowerCase() || '';
        const englishText = line.querySelector(".translation-text")?.innerText.toLowerCase() || '';

        const match = !searchValue || 
          lineTitle.includes(searchValue) || 
          lineText.includes(searchValue) || 
          (englishText && englishText.includes(searchValue));

        line.style.display = match ? "block" : "none";
        if (match) visibleCount++;
      });
      
      // Show "no results" message if needed
      const container = document.getElementById("voicelinesContainer");
      let noResultsMsg = container.querySelector('.no-results-message');
      
      if (searchValue && visibleCount === 0) {
        if (!noResultsMsg) {
          noResultsMsg = document.createElement('div');
          noResultsMsg.className = 'no-results-message';
          noResultsMsg.style.cssText = 'text-align: center; padding: 2rem; color: var(--text-secondary, #a0a0a0);';
          container.appendChild(noResultsMsg);
        }
        noResultsMsg.innerHTML = `<p>No voicelines found matching "${searchValue}"</p>`;
        noResultsMsg.style.display = 'block';
      } else if (noResultsMsg) {
        noResultsMsg.style.display = 'none';
      }
    }

    function handleSmallScreens() {
      document
        .querySelector(".navbar-toggler")
        .addEventListener("click", () => {
          let navbarMenu = document.querySelector(".navbar-menu");

          if (!navbarMenu.classList.contains("active")) {
            navbarMenu.classList.add("active");
          } else {
            navbarMenu.classList.remove("active");
          }
        });
    }

    handleSmallScreens();
  </script>
</body>

</html>